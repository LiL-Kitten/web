Обычный Java Bean:

Определение: Java Bean — это класс, который следует определенным соглашениям, таким как наличие конструктора
без параметров, геттеров и сеттеров для доступа к его свойствам.
Использование: Java Beans могут использоваться в любом Java-приложении и не зависят от какого-либо
контейнера или фреймворка.
Управление жизненным циклом: Обычные бины не имеют встроенного механизма управления жизненным циклом. Разработчик
сам отвечает за создание и уничтожение экземпляров бинов.

Managed Bean:

Определение: Managed Bean — это специальный тип Java Bean, который управляется контейнером
(например, контейнером JSF или CDI - Contexts and Dependency Injection).
Использование: Managed Beans обычно используются в веб-приложениях, особенно в контексте JSF,
для обработки пользовательских запросов и управления состоянием представления.
Управление жизненным циклом: Контейнер управляет жизненным циклом Managed Beans, что включает
создание, инициализацию, уничтожение и внедрение зависимостей. Это позволяет разработчикам сосредоточиться на
бизнес-логике, не беспокоясь о том, как управлять объектами.
Аннотации: Managed Beans часто аннотируются с помощью таких аннотаций, как @ManagedBean,
@RequestScoped, @SessionScoped и т.д., что определяет их область видимости и поведение.

Основные отличия:

Управление: Managed Beans управляются контейнером, в то время как обычные бины создаются и управляются разработчиком.
Область видимости: Managed Beans могут иметь различные области видимости (например, request, session, application),
что позволяет более гибко управлять состоянием приложения.
Интеграция: Managed Beans интегрируются с другими компонентами Java EE, такими как CDI, JSF и EJB, что
упрощает разработку сложных приложений.


--------------------------------------------------Navigetion------------------------------------------------------------

Атрибут `action` указывает метод в Managed Bean, который будет вызван при выполнении действия
(например, нажатии кнопки или ссылки).
Метод может возвращать строку (outcome), которая будет использоваться для определения, куда JSF должен перейти после
выполнения действия.

`outcome` — это значение, возвращаемое методом, указанным в `action`. Оно используется для определения, на какую
страницу следует перейти.
Значение `outcome` должно соответствовать значениям, определенным в навигационных правилах в файле `faces-config.xml`.

Навигация с использованием `faces-config.xml`

Вы можете определить правила навигации в файле `faces-config.xml`, который находится в папке `WEB-INF`. Это позволяет
централизовать управление навигацией.

    <navigation-rule>
        <from-view-id>/home.xhtml</from-view-id>
        <navigation-case>
            <from-outcome>adminPage</from-outcome>
            <to-view-id>/admin.xhtml</to-view-id>
        </navigation-case>
        <navigation-case>
            <from-outcome>userPage</from-outcome>
            <to-view-id>/user.xhtml</to-view-id>
        </navigation-case>
    </navigation-rule>

Вы можете управлять навигацией непосредственно в методах Managed Bean, возвращая строки, которые соответствуют именам
страниц.

    public String navigate() {
        if (userType.equals("admin")) {
            return "adminPage"; // Переход на страницу администратора
        } else {
            return "userPage"; // Переход на страницу пользователя
        }
    }


Вы можете использовать один метод `action`, который будет возвращать разные `outcome` в зависимости от условий.
Это позволяет централизовать логику навигации.

    public String navigate() {
        if ("admin".equals(userType)) {
            return "adminPage"; // Переход на страницу администратора
        } else if ("user".equals(userType)) {
            return "userPage"; // Переход на страницу пользователя
        } else {
            return "home"; // Переход на домашнюю страницу
        }
    }


Использование `faces-config.xml` позволяет централизовать управление навигацией, что упрощает поддержку и изменение
логики навигации.

Вы можете использовать один метод для обработки различных сценариев навигации, что делает код более чистым и управляемым.
Упрощение кода за счет использования одного метода для навигации, что уменьшает дублирование кода и улучшает читаемость.
Вы можете легко добавлять новые условия и страницы, просто изменяя логику в одном месте.
Навигация в JSF легко интегрируется с другими компонентами, такими как формы, ссылки и кнопки, что позволяет создавать
интерактивные веб-приложения.

Навигация в JSF предоставляет мощные инструменты для управления переходами между страницами в веб-приложениях. Используя
`action` и `outcome`, а также возможности конфигурации в `faces-config.xml`, разработчики могут создавать гибкие и
поддерживаемые приложения. Понимание этих концепций и их правильное применение поможет вам эффективно управлять
навигацией в ваших JSF-приложениях.

https://www.w3schools.blog/jsf-navigation-rule

--------------------------------------------------ORM------------------------------------------------------------
Объектно-реляционное отображение (ORM) является ключевой концепцией в области систем управления базами данных (СУБД) ,
которая устанавливает мост между объектно-ориентированным подходом программирования и реляционными базами данных. ORM
имеет решающее значение для упрощения взаимодействия данных, оптимизации кода и плавного смешивания приложений и баз
данных. Цель этой статьи — объяснить ORM, осветив его основные принципы, преимущества и важность в современной
разработке программного обеспечения.

Система управления объектно-реляционными базами данных (ORDBMS)
ORDBMS означает объектно-реляционную систему управления базами данных, которая дополнительно расширяет функциональные
возможности реляционной базы данных путем включения объектно-ориентированных принципов. Она имеет дело со сложными
типами данных, инкапсуляцией, наследованием и другими концепциями объектно-ориентированным способом, что является
правильной поддержкой для приложений, которым требуются как реляционные, так и объектно-ориентированные возможности.

Сущности

В сфере ORM сущности являются синонимами объектов или классов в объектно-ориентированном программировании, которые
привязаны к таблицам в реляционных базах данных. Они служат абстракциями бизнес-объектов или концепций в приложении,
и их определение находится в коде. Компонент ORM выполняет преобразование этих сущностей в таблицы базы данных и, таким
образом, обеспечивает плавную связь между приложением и базой данных, которая лежит в основе этого приложения.

Отношения

Отношения в ORM отображают, как сущности связаны друг с другом, что описывает отношения между таблицами в базе данных.
Эти отношения определяют, как различные элементы связаны друг с другом, и эти отношения являются сутью целостности
данных, а также служат зеркалом между различными компонентами, которые реализованы в приложении.

Упорство

Сохранение относится к возможности сохранять данные после завершения работы приложения. Использование
объектно-реляционного отображения (ORM) обеспечивает сохранение данных даже при закрытии или перезапуске приложения,
поскольку они хранятся в реляционной базе данных, что делает их безопасными и доступными даже при выключенном
приложении. Это самая важная функция ORM, поскольку она обеспечивает временное сохранение данных, используемых
приложением.

Что такое объектно-реляционное отображение (ORM) в СУБД?
С Object-Relational Mapping становится намного проще работать с объектно-ориентированным языком программирования и
реляционной базой данных. По сути, он действует как переводчик, без каких-либо проблем транслируя данные между базой
данных и приложением. ORM позволяет разработчикам работать с объектами на их языке программирования, которые
сопоставляются с соответствующими сущностями базы данных, такими как таблицы, представления или хранимые процедуры.

Ключевые концепции ORM:

Объектно-ориентированная парадигма: ORM фокусируется на принципах ООП, согласно которым данные и поведение
инкапсулируются в объекты. В ORM сущности базы данных сопоставляются с объектами, и разработчики используют объекты для
взаимодействия и манипулирования данными довольно простым способом.

Отображение: Основная цель ORM — отображение объектов в таблицы базы данных и обратно. Отображение определяется через
метаданные, которые представляют взаимосвязи между объектами и соответствующими схемами базы данных. Метаданные
фреймворков ORM используются для генерации SQL-запросов и управления потоком данных между приложением и базой данных.

Операции CRUD: ORM упрощает операции CRUD. Разработчики могут выполнять такие операции над объектами на своем языке
программирования; фреймворк ORM заботится о переводе операций в соответствующие им операторы SQL для базовой базы данных.



В Java существует несколько популярных библиотек ORM (Object-Relational Mapping), которые помогают разработчикам
работать с базами данных, используя объектно-ориентированный подход. Вот некоторые из них:

Hibernate: Одна из самых популярных и мощных ORM-библиотек для Java. Hibernate предоставляет возможность маппинга
Java-объектов на таблицы базы данных и поддерживает множество функций, таких как кэширование, управление транзакциями
и поддержка различных баз данных.
JPA (Java Persistence API): Это спецификация, которая определяет стандартный способ работы с ORM в Java. Hibernate
является одной из реализаций JPA, но существуют и другие, такие как EclipseLink и OpenJPA.
EclipseLink: Это еще одна реализация JPA, которая также поддерживает дополнительные функции, такие как маппинг NoSQL
и интеграцию с Java EE.
MyBatis: Хотя MyBatis не является классической ORM, это фреймворк для работы с базами данных, который позволяет
использовать SQL-запросы и маппить результаты на Java-объекты. Он предоставляет больше контроля над SQL, чем
традиционные ORM.
Spring Data JPA: Это часть Spring Framework, которая упрощает работу с JPA. Она предоставляет репозитории и позволяет
легко создавать запросы, используя методы интерфейсов.
Apache Cayenne: Это ORM-фреймворк, который предлагает мощные инструменты для работы с базами данных и поддерживает
различные типы баз данных.
JOOQ (Java Object Oriented Querying): Это библиотека, которая позволяет писать типобезопасные SQL-запросы в Java.
Хотя это не классическая ORM, она предоставляет удобный способ работы с базами данных.
Каждая из этих библиотек имеет свои особенности и подходит для различных сценариев использования, поэтому выбор зависит
от конкретных требований вашего проекта.


--------------------------------------------------ORM------------------------------------------------------------